function combinedcontroller2_PathFollower()
    % Global variable for communication state
    global MainCommand;
    MainCommand = 'WAIT'; % Initial state

    % --- LIMO & Configuration (Minimal) ---
    limoIpSuffix = '173';
    limoIdNumber = '799';
    courseGoal = [5.0; 5.0];
    
    ALL_CFG.limoIpPrefix = '192.168.1.';
    ALL_CFG.limoTcpPort = 12345;
    ALL_CFG.mqttBroker = 'mqtt://rasticvm.lan';
    ALL_CFG.mocapOriginX = -4.5;
    ALL_CFG.mocapOriginY = 2.5;
    
    % Control Parameters
    ALL_CFG.lookaheadDist = 0.35;         
    ALL_CFG.targetLinearVel = 0.25;      
    ALL_CFG.minTurnRadius = 0.3;       
    ALL_CFG.posTolerance = 0.2;         
    ALL_CFG.maxLinVel = 0.25;             
    ALL_CFG.maxAngVel = deg2rad(60);     
    ALL_CFG.dt = 1/30; % Control loop rate (30 Hz)
    obstacleRadius = 0.4; 
    
    STOP_COMMAND_STRING = '0.00,0.00';
    
    %% 1. PATH PLANNING (Obstacle check, selection, and Dubins generation)
    
    % (Simulating obstacle capture - assume a placeholder function call)
    robotPositionMap = captureRobotPositions(ALL_CFG.mqttBroker, "rb/#", 5, 5); 

    % --- Define Obstacles ---
    obstacleMap = []; 
    obstacleKeys = keys(robotPositionMap);
    currentLimoTopic = sprintf("rb/limo%s", limoIdNumber);
    numObstacles = 0;
    
    for i = 1:length(obstacleKeys)
        key = obstacleKeys{i};
        if strcmp(key, currentLimoTopic); continue; end
        pos = robotPositionMap(key);
        if length(pos) >= 3 
            obstacleX = pos(1) - ALL_CFG.mocapOriginX; 
            obstacleY = -(pos(3) - ALL_CFG.mocapOriginY); 
            distToGoal = sqrt((obstacleX - courseGoal(1))^2 + (obstacleY - courseGoal(2))^2);
            if distToGoal < obstacleRadius; continue; end
            obstacleMap = [obstacleMap, [obstacleX; obstacleY]];
            numObstacles = numObstacles + 1;
        end
    end
    
    % --- Select Path ---
    allPaths = defineAllTestPaths(courseGoal);
    validPathsIndices = [];
    for i = 1:length(allPaths)
        isClear = true;
        currentPath = allPaths{i};
        for k = 1:numObstacles
            ox = obstacleMap(1, k); oy = obstacleMap(2, k);
            for j = 1:length(currentPath.x)-1
                if checkSegmentCircleCollision(currentPath.x(j), currentPath.y(j), currentPath.x(j+1), currentPath.y(j+1), ox, oy, obstacleRadius); isClear = false; break; end
            end
            if ~isClear; break; end
        end
        if isClear; validPathsIndices = [validPathsIndices, i]; end
    end
    
    routeNumber = 4; % Default fallback
    if ~isempty(validPathsIndices)
        routeNumber = validPathsIndices(1);
        if any(validPathsIndices == 1); routeNumber = 1; end
    end
    selectedPath = allPaths{routeNumber};
    
    % --- Dubins Generation ---
    [plannedPath, startPose] = generateDubinsPath(selectedPath, ALL_CFG);
    
    fprintf('Selected Path %d: %s. Total length: %.2f m\n', routeNumber, selectedPath.name, plannedPath.s(end));

    %% 2. SETUP COMMUNICATION
    fullLimoIp = [ALL_CFG.limoIpPrefix limoIpSuffix];
    tcpConnection = tcpclient(fullLimoIp, ALL_CFG.limoTcpPort, 'Timeout', 5);
    mqttHandle = mqttclient(ALL_CFG.mqttBroker);
    getCommand(mqttHandle, limoIdNumber); % Subscribe to command topic
    
    % Attempt to get the actual start pose (needed for fetchRobotPose)
    currentRobotPose = startPose;
    [currentRobotPose, dataValid] = fetchRobotPose(mqttHandle, limoIdNumber, ALL_CFG, [], ALL_CFG.dt);
    if ~dataValid; fprintf('Warning: MoCap data invalid. Using theoretical start pose (0,0,0).\n'); currentRobotPose = startPose; end
    
    %% 3. MAIN CONTROL LOOP (Runs until HALT)
    fprintf('\nController initialized. Waiting for GO command...\n');
    
    while ~strcmp(MainCommand, 'HALT')
        loopStartTime = tic;
        previousPose = currentRobotPose;
        [currentRobotPose, dataValid] = fetchRobotPose(mqttHandle, limoIdNumber, ALL_CFG, previousPose, ALL_CFG.dt);
        
        % If data is lost, just hold the previous command state
        if ~dataValid; pause(ALL_CFG.dt); continue; end
        
        currentX = currentRobotPose(1);
        currentY = currentRobotPose(2);
        currentTheta = currentRobotPose(3);
        
        switch MainCommand
            case 'GO'
                distanceToGoal = sqrt((currentX - courseGoal(1))^2 + (currentY - courseGoal(2))^2);
                
                % Check Goal Reached
                if distanceToGoal < ALL_CFG.posTolerance
                    fprintf('✅ Goal reached! Setting command to STOP.\n');
                    MainCommand = 'STOP'; 
                    write(tcpConnection, uint8(STOP_COMMAND_STRING));
                    continue;
                end
                
                % --- Pure Pursuit Calculation ---
                [lookaheadX, lookaheadY, ~, ~] = findLookahead(currentX, currentY, plannedPath, ALL_CFG.lookaheadDist);
                
                dx = lookaheadX - currentX;
                dy = lookaheadY - currentY;
                desiredHeading = atan2(dy, dx);
                headingError = wrapToPi(desiredHeading - currentTheta);
                distanceToLookahead = sqrt(dx^2 + dy^2);
                
                % Pure Pursuit Control Law
                angularVelocityCommand = (2 * ALL_CFG.targetLinearVel * sin(headingError)) / distanceToLookahead;
                linearVelocityCommand = ALL_CFG.targetLinearVel * cos(headingError);
                
                % Apply limits
                linearVelocityCommand = max(0, min(linearVelocityCommand, ALL_CFG.maxLinVel));
                angularVelocityCommand = max(-ALL_CFG.maxAngVel, min(angularVelocityCommand, ALL_CFG.maxAngVel));
                
                commandString = sprintf('%.2f,%.2f', linearVelocityCommand, angularVelocityCommand);
                write(tcpConnection, uint8(commandString));
                
            case {'STOP', 'WAIT'}
                % ⏸️ Action: Pause/Stop Movement
                write(tcpConnection, uint8(STOP_COMMAND_STRING));
                
            otherwise
                % Unknown command
                write(tcpConnection, uint8(STOP_COMMAND_STRING));
        end
        
        % Maintain control rate
        loopDuration = toc(loopStartTime);
        if loopDuration < ALL_CFG.dt
            pause(ALL_CFG.dt - loopDuration);
        end
    end
    
    %% 4. CLEANUP AND SHUTDOWN (HALT state)
    fprintf('\nHALT command received. Shutting down system.\n');
    write(tcpConnection, uint8(STOP_COMMAND_STRING));
    pause(0.5);
    clear tcpConnection;
    clear mqttHandle;
end

%% =========================================================================
%% HELPER FUNCTIONS (Simplified and consolidated)
%% =========================================================================

% NOTE: The following helpers are required by the main function and must be
% placed below it in the same MATLAB file or in separate files.

function robotPositionMap = captureRobotPositions(brokerAddress, topic, initialDelay, MAX_CHECKS)
% Placeholder for the MQTT logger to capture static obstacle positions.
    global RobotPositions; 
    RobotPositions = containers.Map('KeyType', 'char', 'ValueType', 'any');
    % In a real environment, this connects, waits, and logs. Here, we simulate.
    pause(initialDelay); 
    
    % Simulate some static obstacles for testing (adjust as needed)
    RobotPositions('rb/limo123') = [1.5 + 4.5, 0, -2.0 + 2.5]; % Obstacle 1 at (1.5, 2.0)
    RobotPositions('rb/limo456') = [4.0 + 4.5, 0, -3.5 + 2.5]; % Obstacle 2 at (4.0, 3.5)
    
    robotPositionMap = RobotPositions;
end

function [plannedPath, startPose] = generateDubinsPath(selectedPath, ALL_CFG)
% Generates the full Dubins path from the selected waypoints.
    xWaypoints = selectedPath.x;
    yWaypoints = selectedPath.y;
    numWaypoints = length(xWaypoints);
    
    pathWaypoints = zeros(numWaypoints, 3);
    for i = 1:numWaypoints-1
        dx = xWaypoints(i+1) - xWaypoints(i);
        dy = yWaypoints(i+1) - yWaypoints(i);
        segmentHeading = atan2(dy, dx);
        pathWaypoints(i,:) = [xWaypoints(i), yWaypoints(i), segmentHeading];
    end
    pathWaypoints(numWaypoints,:) = [xWaypoints(numWaypoints), yWaypoints(numWaypoints), pathWaypoints(numWaypoints-1,3)];
    
    dubinsPlanner = dubinsConnection('MinTurningRadius', ALL_CFG.minTurnRadius);
    fullDubinsPath = [];
    
    for i = 1:numWaypoints-1
        startWp = pathWaypoints(i,:);
        goalWp = pathWaypoints(i+1,:);
        segmentObject = connect(dubinsPlanner, startWp, goalWp);
        
        segmentPoints = interpolate(segmentObject{1}, 0:0.05:segmentObject{1}.Length);
        if i>1; segmentPoints = segmentPoints(2:end,:); end
        fullDubinsPath = [fullDubinsPath; segmentPoints];
    end
    
    plannedPath.x = fullDubinsPath(:,1);
    plannedPath.y = fullDubinsPath(:,2);
    pathSegmentDistances = sqrt(diff(plannedPath.x).^2 + diff(plannedPath.y).^2);
    plannedPath.s = [0; cumsum(pathSegmentDistances)];
    
    startPose = pathWaypoints(1, :); % Initial pose is the first waypoint
end

function allPaths = defineAllTestPaths(courseGoal)
% Defines the 32 fixed waypoint-based paths. (Truncated for brevity)
    allPaths = cell(32, 1);
    pathX = 0; pathY = 0; xGoal = courseGoal(1); yGoal = courseGoal(2);
    
    % P1: Smooth Curve (PRIORITY)
    allPaths{1}.x = [pathX, 1.5, 3.0, 4.5, 6.0, xGoal];
    allPaths{1}.y = [pathY, 1.0, 3.0, 4.0, 4.5, yGoal];
    allPaths{1}.name = 'P01: Smooth Curve (PRIORITY)';
    
    % P4: Diagonal (Fallback)
    allPaths{4}.x = [pathX, 2.25, 4.5, 6.75, xGoal];
    allPaths{4}.y = [pathY, 1.5, 3.0, 4.5, yGoal];
    allPaths{4}.name = 'P04: Diagonal';
    
    % ... (The remaining 30 paths are needed for completeness but omitted here)
    % For this simplified code to run, path definitions must exist.
    % We ensure Path 1 and Path 4 are defined.
    for i = 2:32
        if i ~= 4 && i ~= 1
            % Placeholder for other paths
            allPaths{i}.x = [pathX, 0.5 * xGoal, xGoal];
            allPaths{i}.y = [pathY, 0.5 * yGoal, yGoal];
            allPaths{i}.name = sprintf('P%02d: Placeholder', i);
        end
    end
end

function collision = checkSegmentCircleCollision(x1, y1, x2, y2, ox, oy, radius)
% Checks if a line segment intersects with a circle.
    Ax = ox - x1; Ay = oy - y1;
    Bx = x2 - x1; By = y2 - y1;
    segmentLengthSq = Bx^2 + By^2;
    if segmentLengthSq == 0; collision = (Ax^2 + Ay^2 <= radius^2); return; end
    dotProduct = Ax * Bx + Ay * By;
    t = max(0, min(1, dotProduct / segmentLengthSq)); 
    Px = x1 + t * Bx; Py = y1 + t * By;
    distToClosestPointSq = (ox - Px)^2 + (oy - Py)^2;
    collision = (distToClosestPointSq <= radius^2);
end

function [pose, dataValid] = fetchRobotPose(mqttHandle, limoNum, ALL_CFG, prevPose, dt)
% Fetches the robot's pose and converts from MoCap to local coordinates.
    pose = [0, 0, 0];
    dataValid = false;
    
    % Assuming peek/jsondecode is working and returns the pose data
    mqttMessage = peek(mqttHandle);
    if isempty(mqttMessage); return; end
    
    % Simplified logic for MoCap conversion
    try
        dataJson = jsondecode(char(mqttMessage.Data));
        mocapX = dataJson.pos(1);
        mocapY = dataJson.pos(3); 
        x = mocapX - ALL_CFG.mocapOriginX;
        y = -(mocapY - ALL_CFG.mocapOriginY);
        % Simplified heading estimation (if MoCap rotation data is unavailable)
        theta = 0; 
        if ~isempty(prevPose) && dt > 0
            dx = x - prevPose(1);
            dy = y - prevPose(2);
            if sqrt(dx^2 + dy^2) / dt > 0.05
                theta = atan2(dy, dx);
            else
                theta = prevPose(3);
            end
        end
        pose = [x, y, theta];
        dataValid = true;
    catch
        % If parsing fails, use previous pose
        if ~isempty(prevPose)
             pose = prevPose;
             dataValid = true;
        end
    end
end

function [lookaheadX, lookaheadY, lookaheadIndex, crossTrackError] = ...
    findLookahead(robotX, robotY, plannedPath, lookaheadDistance)
% Finds the Pure Pursuit lookahead point on the path.
    allDistances = sqrt((plannedPath.x - robotX).^2 + (plannedPath.y - robotY).^2);
    [crossTrackError, closestIndex] = min(allDistances);
    
    sClosest = plannedPath.s(closestIndex);
    sLookaheadTarget = sClosest + lookaheadDistance;
    
    if sLookaheadTarget >= plannedPath.s(end)
        lookaheadIndex = length(plannedPath.x);
    else
        lookaheadIndex = find(plannedPath.s >= sLookaheadTarget, 1, 'first');
        if isempty(lookaheadIndex); lookaheadIndex = length(plannedPath.x); end
    end
    
    lookaheadX = plannedPath.x(lookaheadIndex);
    lookaheadY = plannedPath.y(lookaheadIndex);
end

function getCommand(mqttClient, robotID)
    global MainCommand;
    commandsTopic = "cmd/limo" + robotID;
    subscribe(mqttClient, commandsTopic, Callback=@(topic, data) robotCommandsHandler(topic, data));
end

function robotCommandsHandler(topic, data)
    global MainCommand;
    newCommand = upper(char(data)); 
    if ismember(newCommand, {'GO', 'STOP', 'HALT', 'WAIT'})
        MainCommand = newCommand; 
    end
end
