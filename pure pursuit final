function combinedcontroller2_Final()
    global MainCommand;
    global GOAL;
    MainCommand = 'WAIT'; % Set initial command to WAIT/STOP

% This script first runs an MQTT logger to capture the final positions of all
% other robots, uses those positions as obstacles, and then selects an
% obstacle-free Dubins path for the local LIMO using Pure Pursuit control.
    % Clear workspace and close all figures for a fresh start
    clearvars; close all;
    obsX = []; 
    obsY = [];
    % --- LIMO Network Configuration ---
    limoIpSuffix = '173';
    limoIdNumber = '799';
    
    fprintf('\n--- LIMO Network Configuration ---\n');
    fprintf('IP last 3 digits: %s\n', limoIpSuffix);
    fprintf('LIMO number: %s\n', limoIdNumber);
    
    % Final destination [x; y] - 
   
    xGoal = 5;
    yGoal = 5;
     courseGoal = [xGoal; yGoal];
    % --- Configuration Structure (Defining MoCap Origin Early for Obstacles) ---
    ALL_CFG.mocapOriginX = -4.5;
    ALL_CFG.mocapOriginY = 2.5;
    %% STEP 0. CAPTURE ROBOT POSITIONS 
   
    % --- MQTT Configuration for Obstacle/Robot Tracking ---
    obstacleMqttBroker = 'mqtt://rasticvm.lan';
    allRobotsTopic = "rb/#"; 
    initialDelay = 5; 
    MAX_CHECKS = 5; 
    
    robotPositionMap = captureRobotPositions(obstacleMqttBroker, allRobotsTopic, initialDelay, MAX_CHECKS);
    
    %% 1. DEFINE OBSTACLES 
    obstacleRadius = 0.3; 
    obstacleKeys = keys(robotPositionMap);
    obstacleMap = []; 
    obstacleLabels = {}; 
    numObstacles = 0;
    currentLimoTopic = sprintf("rb/limo%s", limoIdNumber);
    
    for i = 1:length(obstacleKeys)
        key = obstacleKeys{i};
        if strcmp(key, currentLimoTopic)
            fprintf('  Ignoring own LIMO position (%s) as an obstacle.\n', key);
            continue;
        end
        pos = robotPositionMap(key);
        if length(pos) >= 3 
            mocapX = pos(1);
            mocapZ = pos(3); 
            obstacleX = mocapX - ALL_CFG.mocapOriginX; 
            obstacleY = -(mocapZ - ALL_CFG.mocapOriginY); 
            distToGoal = sqrt((obstacleX - courseGoal(1))^2 + (obstacleY - courseGoal(2))^2);
            if distToGoal < obstacleRadius
                 fprintf('  Warning: Ignoring obstacle at (%.2f, %.2f) near goal.\n', obstacleX, obstacleY);
                 continue;
            end
            labelParts = split(key, '/');
            robotID = labelParts{end};
            obstacleMap = [obstacleMap, [obstacleX; obstacleY]];
            obstacleLabels{end+1} = robotID; 
            numObstacles = numObstacles + 1;
            fprintf('  Obstacle added: Robot %s at (X=%.2f, Y=%.2f) (Local Coords)\n', robotID, obstacleX, obstacleY);
        end
    end
  
    if numObstacles > 0
        save('obstacle_positions.mat', 'obstacleMap');
        fprintf('  >> Final obstacle coordinates saved to: obstacle_positions.mat\n');
        
        % Optionally, display the array (uncomment if needed)
        disp('    --- obstacleMap array content (X, Y): ---');
        disp(obstacleMap);
        disp('    ------------------------------------------');
    end
    % -----------------------------------------------------------
    
    %% 2. DEFINE 32 TEST PATHS (X-range scaled to ~7.5)
    
    if numObstacles == 0
        fprintf('  No other robots found to serve as obstacles.\n');
    else
        fprintf('  Total obstacles derived from other robots: %d\n', numObstacles);
    end
    
    % Store all paths in a cell array for iteration
    allPaths = cell(32, 1);
    pathX = 0; %Starting Positions
    pathY = 0;
    
    % --- 1. General Forward Paths (BL -> TR) ---
    
    % P1: Smooth Curve (PRIORITY)
    allPaths{1}.x = [pathX, 1.5, 3.0, 4.5, 6.0, xGoal];
    allPaths{1}.y = [pathY, 1.0, 3.0, 4.0, 4.5, yGoal];
    allPaths{1}.name = 'P01: Smooth Curve (PRIORITY)';
    
    % P2: Sharp Turns
    allPaths{2}.x = [pathX, 0.75, 6.75, 6.75, xGoal];
    allPaths{2}.y = [pathY, 4.5, 4.5, 0.5, yGoal];
    allPaths{2}.name = 'P02: Sharp Turns';
    
    % P3: Zig-Zag
    allPaths{3}.x = [pathX, 3.0, 1.5, 3.0, 6.0, xGoal];
    allPaths{3}.y = [pathY, 1.0, 2.0, 4.0, 4.5, yGoal];
    allPaths{3}.name = 'P03: Zig-Zag';
    
    % P4: Diagonal
    allPaths{4}.x = [pathX, 2.25, 4.5, 6.75, xGoal];
    allPaths{4}.y = [pathY, 1.5, 3.0, 4.5, yGoal];
    allPaths{4}.name = 'P04: Diagonal';
    
    % P5: Top Edge Hugging
    allPaths{5}.x = [pathX, 0.75, 2.25, 5.25, 6.75, xGoal];
    allPaths{5}.y = [pathY, 4.8, 4.8, 4.8, 4.8, yGoal];
    allPaths{5}.name = 'P05: Top Edge Hugging';
    
    % P6: Left Wall S-Curve (Original P8)
    allPaths{6}.x = [pathX, 0.3, 7.2, 0.3, xGoal];
    allPaths{6}.y = [pathY, 2.0, 3.0, 4.8, yGoal];
    allPaths{6}.name = 'P06: Left Wall S-Curve';
    
    % P7: Long Weave (Original P9)
    allPaths{7}.x = [pathX, 1.5, 6.0, 3.0, xGoal];
    allPaths{7}.y = [pathY, 4.0, 1.0, 4.5, yGoal];
    allPaths{7}.name = 'P07: Long Weave';
    
    % P8: Top-Left Corner Hug (Original P11)
    allPaths{8}.x = [pathX, 0.3, 0.3, 7.2, xGoal];
    allPaths{8}.y = [pathY, 0.2, 4.8, 4.8, yGoal];
    allPaths{8}.name = 'P08: Top-Left Corner Hug';
    
    % P9: Mirrored Zig-Zag (X-Y Swap, Original P12)
    % Note: X-coordinates are scaled, Y-coordinates are NOT (as they were original X-coords)
    allPaths{9}.x = [pathX, 1.5, 3.0, 4.5, 6.0, 6.75, xGoal];
    allPaths{9}.y = [pathY, 2.0, 1.0, 3.0, 2.0, 4.0, yGoal];
    allPaths{9}.name = 'P09: Zig-Zag (X-Y Swap)';
    
    % P10: Half Circle Arc (Upper Half, Original P13)
    allPaths{10}.x = [pathX, 5.25, 4.5, 3.75, 4.5, 2.25, xGoal];
    allPaths{10}.y = [pathY, 4.0, 3.5, 2.5, 1.5, 1.0, yGoal];
    allPaths{10}.name = 'P10: Half Circle Arc';
    
    % P11: Right Wall S-Curve (Original P14)
    allPaths{11}.x = [pathX, 7.2, 0.3, 7.2, xGoal];
    allPaths{11}.y = [pathY, 2.0, 3.0, 0.2, yGoal];
    allPaths{11}.name = 'P11: Right Wall S-Curve';
    
    % P12: Center Cross (Original P7)
    allPaths{12}.x = [pathX, 3.75, 3.75, xGoal];
    allPaths{12}.y = [pathY, 2.5, 4.5, yGoal];
    allPaths{12}.name = 'P12: Center Cross';
    
    % P13: Wide Bottom Edge Hug (Original P19)
    allPaths{13}.x = [pathX, 1.5, 3.75, 6.0, xGoal];
    allPaths{13}.y = [pathY, 0.2, 0.2, 0.2, yGoal];
    allPaths{13}.name = 'P13: Wide Bottom Edge Hug';
    
    % P14: Upper Half Arc (Original P26)
    allPaths{14}.x = [pathX, 1.5, 3.75, 6.0, xGoal];
    allPaths{14}.y = [pathY, 2.0, 4.0, 2.0, yGoal];
    allPaths{14}.name = 'P14: Upper Half Arc';
    
    % P15: Lower Half Arc (Original P27)
    allPaths{15}.x = [pathX, 1.5, 3.75, 6.0, xGoal];
    allPaths{15}.y = [pathY, 3.0, 1.0, 3.0, yGoal];
    allPaths{15}.name = 'P15: Lower Half Arc';
   
    % --- 2. Reverse Paths (TR -> BL) ---
    
    % P16: Reverse Smooth Curve (New - from P1)
    allPaths{16}.x = [pathX, 6.0, 4.5, 3.0, 1.5, xGoal];
    allPaths{16}.y = [pathY, 4.0, 2.0, 1.0, 0.5, yGoal];
    allPaths{16}.name = 'P16: Reverse Smooth Curve';

    %% 3. PATH VALIDATION CHECK (MODIFIED PRIORITY LOGIC)
    fprintf('\n=======================================================\n');
    fprintf('3. PATH VALIDATION CHECK\n');
    fprintf('   Priority: Path 1 > Lowest Index Clear Path\n');
    fprintf('=======================================================\n');
    
    % Array to store indices of all valid paths found
    validPathsIndices = [];
    
    for i = 1:length(allPaths)
        currentPath = allPaths{i};
        isClear = true;
        
        % Check if any obstacle intersects the line segments of the path
        for j = 1:length(currentPath.x)-1
            x1 = currentPath.x(j);
            y1 = currentPath.y(j);
            x2 = currentPath.x(j+1);
            y2 = currentPath.y(j+1);
            
            % Check intersection with all obstacles
            for k = 1:numObstacles
                ox = obstacleMap(1, k);
                oy = obstacleMap(2, k);
                
                % Call helper function to check line segment-circle collision
                if checkSegmentCircleCollision(x1, y1, x2, y2, ox, oy, obstacleRadius)
                    isClear = false;
                    fprintf(' Path %d (%s) blocked by obstacle (%s) at (%.2f, %.2f)\n', ...
                            i, currentPath.name, obstacleLabels{k}, ox, oy);
                    break; 
                end
            end
            if ~isClear
                break; 
            end
        end
        
        if isClear
            validPathsIndices = [validPathsIndices, i];
            fprintf(' Path %d (%s) is clear.\n', i, currentPath.name);
        end
    end
    
    % --- PATH SELECTION LOGIC ---
    if isempty(validPathsIndices)
        % Fallback if no paths are clear
        routeNumber = 4; % Fallback to Path 4 (Diagonal)
        xWaypoints = allPaths{routeNumber}.x;
        yWaypoints = allPaths{routeNumber}.y;
        warning('No obstacle-free path found among all 10 paths. Falling back to Path 4 (Diagonal).');
    elseif any(validPathsIndices == 1)
        % Priority: Path 1 is clear
        routeNumber = 1;
        xWaypoints = allPaths{routeNumber}.x;
        yWaypoints = allPaths{routeNumber}.y;
        fprintf('\nAuto-selecting Course %d: %s (Priority Selection)\n', routeNumber, allPaths{routeNumber}.name);
    else
        % Secondary Selection: Use the lowest index clear path
        routeNumber = validPathsIndices(1);
        xWaypoints = allPaths{routeNumber}.x;
        yWaypoints = allPaths{routeNumber}.y;
        fprintf('\nAuto-selecting Course %d: %s (First clear path found)\n', routeNumber, allPaths{routeNumber}.name);
    end
    
    % Display summary
    fprintf('  Obstacles: %d points (Radius %.2f m)\n', size(obstacleMap, 2), obstacleRadius);
    fprintf('  Goal: [%.1f, %.1f]\n', courseGoal(1), courseGoal(2));
    fprintf('  Path waypoints: %d points\n\n', length(xWaypoints));
    disp(obsX)
    disp(obsY)
    %% PARAMETERS (UNCHANGED)
    ALL_CFG.limoIpPrefix = '192.168.1.';
    ALL_CFG.limoTcpPort = 12345;
    ALL_CFG.mqttBroker = 'mqtt://rasticvm.lan';
    ALL_CFG.lookaheadDist = 0.35;         
    ALL_CFG.targetLinearVel = 0.25;      
    ALL_CFG.minTurnRadius = 0.3;       
    ALL_CFG.recoveryDuration = 1.0;     
    ALL_CFG.posTolerance = 0.2;         
    ALL_CFG.headingTolerance = deg2rad(25);
    ALL_CFG.maxLinVel = 0.25;             
    ALL_CFG.maxAngVel = deg2rad(60);     
    ALL_CFG.maxTotalTime = 360;          
    ALL_CFG.controlRate = 30;            
    ALL_CFG.dt = 1/ALL_CFG.controlRate;  
    % Initialize communication objects
    tcpConnection = [];
    mqttHandle = [];
    
    try
        
        %% PREPARE NOMINAL PATH WAYPOINTS
        fprintf('Validating and preparing waypoints...\n');
        numWaypoints = length(xWaypoints);
        if length(yWaypoints) ~= numWaypoints
            error('Waypoints and yWaypoints must have the same length');
        end
        
        pathWaypoints = zeros(numWaypoints, 3);
        for i = 1:numWaypoints-1
            dx = xWaypoints(i+1) - xWaypoints(i);
            dy = yWaypoints(i+1) - yWaypoints(i);
            segmentHeading = atan2(dy, dx);
            pathWaypoints(i,:) = [xWaypoints(i), yWaypoints(i), segmentHeading];
        end
        pathWaypoints(numWaypoints,:) = [xWaypoints(numWaypoints), yWaypoints(numWaypoints), pathWaypoints(numWaypoints-1,3)];
        fprintf('Waypoints processed: %d points\n', numWaypoints);
        
        %% LIMO TCP CONNECTION
        fullLimoIp = [ALL_CFG.limoIpPrefix limoIpSuffix];
        fprintf('Connecting to LIMO TCP: %s:%d\n', fullLimoIp, ALL_CFG.limoTcpPort);
        tcpConnection = tcpclient(fullLimoIp, ALL_CFG.limoTcpPort, 'Timeout', 5);
        write(tcpConnection, uint8('0.00,0.00'));
        pause(0.5);
        
        %% MQTT CONNECTION AND COMMAND SUBSCRIPTION
        fprintf('Connecting to MQTT broker for control feedback: %s\n', ALL_CFG.mqttBroker);
        mqttHandle = mqttclient(ALL_CFG.mqttBroker);
        subscribe(mqttHandle, sprintf("rb/limo%s", limoIdNumber));
        
        % Ensure the command subscription is active before the control loop starts
        getCommand(mqttHandle, limoIdNumber); 
        fprintf('Subscribed to command topic for LIMO %s. Initial command: %s\n', limoIdNumber, MainCommand);
        
        fprintf('\nWaiting for MoCap data to stabilize...\n');
        waitTime = 2; 
        for i = 1:waitTime
            fprintf('  %d/%d seconds... ', i, waitTime);
            [testPose, dataReceived] = fetchRobotPose(mqttHandle, limoIdNumber, ALL_CFG, [], 0);
            if dataReceived
                fprintf('Current data: (%.2f, %.2f, %.1f°)\n', testPose(1), testPose(2), rad2deg(testPose(3)));
            else
                fprintf('No data yet\n');
            end
            pause(1);
        end
        fprintf('Wait complete \n\n');
        fprintf('Reading initial robot position...\n');
        initialPoseFound = false;
        maxAttempts = 5;
        currentPose = [0, 0, 0];
        for attempt = 1:maxAttempts
            [currentPose, initialPoseFound] = fetchRobotPose(mqttHandle, limoIdNumber, ALL_CFG, [], 0);
            if initialPoseFound
                fprintf('Start pose: (%.2f, %.2f, %.1f°)\n', currentPose(1), currentPose(2), rad2deg(currentPose(3)));
                break;
            end
            fprintf('  Attempt %d/%d: No data...\n', attempt, maxAttempts);
            pause(0.5);
        end
        
        if ~initialPoseFound
            error('Cannot read MoCap data');
        end
        startPose = currentPose;
        %% GENERATE DUBINS PATH
        fprintf('Generating smooth Dubins path between waypoints...\n');
        fullDubinsPath = [];
        dubinsPlanner = dubinsConnection('MinTurningRadius', ALL_CFG.minTurnRadius);
        
        for i = 1:numWaypoints-1
            startWp = pathWaypoints(i,:);
            goalWp = pathWaypoints(i+1,:);
            [segmentObject,~] = connect(dubinsPlanner, startWp, goalWp);
            
            if isempty(segmentObject)
                error('Dubins path segment between waypoints %d and %d failed', i, i+1);
            end
            
            segmentPoints = interpolate(segmentObject{1}, 0:0.05:segmentObject{1}.Length);
            if i>1
                segmentPoints = segmentPoints(2:end,:);
            end
            fullDubinsPath = [fullDubinsPath; segmentPoints];
        end
        
        plannedPath.x = fullDubinsPath(:,1);
        plannedPath.y = fullDubinsPath(:,2);
        pathSegmentDistances = sqrt(diff(plannedPath.x).^2 + diff(plannedPath.y).^2);
        plannedPath.s = [0; cumsum(pathSegmentDistances)];
        fprintf('Dubins path generated: %d points, total length = %.2f m\n', ...
                length(plannedPath.x), plannedPath.s(end));
        
    
    %% VISUALIZATION SETUP
    figure('Name','LIMO Path Following','Position',[100 100 1000 800]);
    
    plot(obstacleMap(1,:), obstacleMap(2,:), 'ko', 'MarkerSize', 12, 'MarkerFaceColor', 'k', 'DisplayName', 'Obstacles');
    hold on; grid on; axis equal;
    plot(xWaypoints, yWaypoints, 'b--o', 'LineWidth', 2.5, 'MarkerSize', 5, 'DisplayName', 'Waypoints');
    plot(plannedPath.x, plannedPath.y, 'g-', 'LineWidth', 1.0, 'DisplayName', 'Dubins Path');
    plot(courseGoal(1), courseGoal(2), 'bx', 'MarkerSize', 25, 'LineWidth', 3, 'DisplayName', 'Goal');
    plot(startPose(1), startPose(2), 'r*', 'MarkerSize', 18, 'MarkerFaceColor', 'r', 'DisplayName', 'Start');
    actualTrajectoryPlot = plot(NaN, NaN, 'k:', 'LineWidth', 3.0, 'DisplayName', 'Actual Path');
    robotMarker = plot(NaN, NaN, 'go', 'MarkerSize', 14, 'MarkerFaceColor', 'g', 'DisplayName', 'Robot');
    lookaheadMarker = plot(NaN, NaN, 'ro', 'MarkerSize', 8, 'MarkerFaceColor', 'r', 'DisplayName', 'Lookahead Point');
    xlabel('X Position [m]'); ylabel('Y Position [m]');
    title(sprintf('LIMO %s - Pure Pursuit Control (Course %d: %s)', limoIdNumber, routeNumber, allPaths{routeNumber}.name));
    legend('Location', 'best');
    xlim([-0.5 5.5]); 
    ylim([-0.5 5.5]); 
    
        %% CONTROL LOOP - WAITING FOR 'GO' COMMAND
        fprintf('\nWaiting for GO command to be published to cmd/limo%s...\n', limoIdNumber);
    
        % --- Wait for GO loop ---
        while ~strcmp(MainCommand, 'GO')
            % Send a stop command while waiting
            if ~isempty(tcpConnection) && isvalid(tcpConnection)
                write(tcpConnection, uint8('0.00,0.00'));
            end
            % Pause to prevent maxing out CPU and to wait for MQTT message
            pause(0.2); 
            fprintf('  Waiting... Current Command: %s\n', MainCommand);
        end
        
        fprintf('\nGO command received! Starting control loop...\n');
        
        timerStart = tic;                 
        currentRobotPose = startPose;     
        robotTrajectory = startPose(1:2); 
        errorHistory = [];                   
        recoveryTimer = [];                  
        
        while strcmp(MainCommand, 'GO') % Core logic runs ONLY while MainCommand is 'GO'
            loopStartTime = tic;
            previousPose = currentRobotPose;
            [currentRobotPose, dataValid] = fetchRobotPose(mqttHandle, limoIdNumber, ALL_CFG, previousPose, ALL_CFG.dt);
            
            if ~dataValid
                fprintf(' Lost MoCap data - keeping previous command\n');
                continue; 
            end
            
            currentX = currentRobotPose(1);
            currentY = currentRobotPose(2);
            currentTheta = currentRobotPose(3);
            
            elapsedTime = toc(timerStart);
            
            distanceToGoal = sqrt((currentX - courseGoal(1))^2 + (currentY - courseGoal(2))^2);
            
            % --- Termination Conditions ---
            if distanceToGoal < ALL_CFG.posTolerance
                fprintf('\n Goal reached at %.1f s\n', elapsedTime);
                MainCommand = 'STOP'; % Set command to stop to exit the loop gracefully
                write(tcpConnection, uint8('0.00,0.00')); 
                break;
            end
            
            if elapsedTime > ALL_CFG.maxTotalTime
                fprintf('✗ Maximum time limit reached, stopping the code\n');
                MainCommand = 'STOP'; % Set command to stop to exit the loop gracefully
                break;
            end
            
            [lookaheadX, lookaheadY, lookaheadIndex, crossTrackError] = findLookahead(currentX, currentY, plannedPath, ALL_CFG.lookaheadDist);
            
            errorHistory = [errorHistory, crossTrackError];
            if length(errorHistory) > 30
                errorHistory = errorHistory(end-29:end);
            end
           
            if ~isempty(recoveryTimer)
                recoveryElapsed = toc(recoveryTimer);
                if recoveryElapsed < ALL_CFG.recoveryDuration
                    linearVelocityCommand = 0.0;
                    angularVelocityCommand = deg2rad(30); 
                    fprintf('  Recovery: reorienting (%.1f/%.1f s)\n', recoveryElapsed, ALL_CFG.recoveryDuration);
                else
                    fprintf('Recovery complete\n');
                    recoveryTimer = []; 
                end
            else
                dx = lookaheadX - currentX;
                dy = lookaheadY - currentY;
                desiredHeading = atan2(dy, dx);
                headingError = wrapToPi(desiredHeading - currentTheta);
                distanceToLookahead = sqrt(dx^2 + dy^2);
                angularVelocityCommand = (2 * ALL_CFG.targetLinearVel * sin(headingError)) / distanceToLookahead;
                
                if abs(headingError) < deg2rad(90)
                    linearVelocityCommand = ALL_CFG.targetLinearVel * cos(headingError);
                else
                    linearVelocityCommand = ALL_CFG.targetLinearVel * 0.3;
                end
            end
            
            linearVelocityCommand = max(0, min(linearVelocityCommand, ALL_CFG.maxLinVel));
            angularVelocityCommand = max(-ALL_CFG.maxAngVel, min(angularVelocityCommand, ALL_CFG.maxAngVel));
            
            commandString = sprintf('%.2f,%.2f', linearVelocityCommand, angularVelocityCommand);
            write(tcpConnection, uint8(commandString));
            
            robotTrajectory = [robotTrajectory; currentX, currentY]; 
            set(robotMarker, 'XData', currentX, 'YData', currentY);
            set(actualTrajectoryPlot, 'XData', robotTrajectory(:,1), 'YData', robotTrajectory(:,2));
            set(lookaheadMarker, 'XData', lookaheadX, 'YData', lookaheadY);
            
            title(sprintf('LIMO %s - Course %d | t=%.1fs | distToGoal=%.2fm |  V=%.2f, W=%.1f°/s', ...
                         limoIdNumber, routeNumber, elapsedTime, distanceToGoal,  linearVelocityCommand, rad2deg(angularVelocityCommand)));
            drawnow limitrate;
            
            loopDuration = toc(loopStartTime);
            if loopDuration < ALL_CFG.dt
                pause(ALL_CFG.dt - loopDuration);
            end
        end
        
    catch exception
        fprintf('Error: %s\n', exception.message);
        if ~isempty(exception.stack)
            fprintf('  In: %s (line %d)\n', exception.stack(1).name, exception.stack(1).line);
        end
    end
    
    %% CLEANUP AND SHUTDOWN
    if ~isempty(tcpConnection) && isvalid(tcpConnection)
        write(tcpConnection, uint8('0.00,0.00'));
        pause(0.5);
        clear tcpConnection;
    end
    if ~isempty(mqttHandle)
        clear mqttHandle;
    end
    fprintf('Script execution finished.\n\n');
end
%% =========================================================================
%% HELPER FUNCTIONS (UNCHANGED from previous complete version)
%% =========================================================================
function robotPositionMap = captureRobotPositions(brokerAddress, topic, initialDelay, MAX_CHECKS)
    % Global variables for data passing in MQTT callbacks
    global RobotPositions; 
    global StopFlag;
    global GOAL;
    
    RobotPositions = containers.Map('KeyType', 'char', 'ValueType', 'any');
    StopFlag = false;
    currentCheck = 0;
    
    try 
       mqttClient = mqttclient(brokerAddress);
       subscribe(mqttClient, topic, Callback=@robotCaptureMessageHandler);
       
       fprintf('  Connected to MQTT Broker: %s\n', brokerAddress);
       fprintf('  Subscribed to: %s\n', topic);
    catch ME
        warning('MQTT_SETUP:FailedConnect', 'Could not connect to the MQTT broker. Error: %s', ME.message);
        robotPositionMap = containers.Map('KeyType', 'char', 'ValueType', 'any');
        return;
    end
    fprintf('  Waiting for %d seconds to allow robots to reach final poses...\n', initialDelay);
    pause(initialDelay); 
    disp('  Initial delay complete. Starting position logging sequence.');
    while (currentCheck < MAX_CHECKS) && (~StopFlag)
        pause(0.1); 
        if ~isempty(RobotPositions)
            logCurrentCapturedPositions(currentCheck, MAX_CHECKS);
        end
        currentCheck = currentCheck + 1;
    end
    
    clear mqttClient;
    disp('  MQTT connection closed. Captured positions stored.');
    robotPositionMap = RobotPositions;
end
function robotCaptureMessageHandler(topic, data)
    global RobotPositions;
    global StopFlag; 
    
    if StopFlag 
        return;
    end
    
    try
        jsonString = char(data); 
        decodedData = jsondecode(jsonString);
        robotPosition = decodedData.pos; 
        
        hasChanged = true; 
        if isKey(RobotPositions, topic)
            oldPosition = RobotPositions(topic);
            if isequal(oldPosition, robotPosition)
                hasChanged = false;
            end
        end
        
        if hasChanged
            RobotPositions(topic) = robotPosition;
        end
        
    catch ME
        % Suppress warnings
    end
end
function logCurrentCapturedPositions(currentCheck, MAX_CHECKS)
    global RobotPositions;
    
    keyList = keys(RobotPositions);
    
    if isempty(keyList)
        return;
    end
    
    fprintf('  --- Check %d/%d: Robot Positions (MoCap X, Z) ---\n', currentCheck + 1, MAX_CHECKS);
    
    for k = keyList
        topic = k{1};
        positionArray = RobotPositions(topic);
        
        labelParts = split(topic, '/');
        robotID = labelParts{end};
        
        if isnumeric(positionArray) && length(positionArray) >= 3
            currentX = positionArray(1); 
            currentZ = positionArray(3); 
            
            fprintf('  **Robot %s**: X=%.2f, Z=%.2f\n', ...
                    robotID, currentX, currentZ);
        end
    end
end
function collision = checkSegmentCircleCollision(x1, y1, x2, y2, ox, oy, radius)
    Ax = ox - x1;
    Ay = oy - y1;
    Bx = x2 - x1;
    By = y2 - y1;
    
    segmentLengthSq = Bx^2 + By^2;
    if segmentLengthSq == 0
        distSq = Ax^2 + Ay^2;
        collision = (distSq <= radius^2);
        return;
    end
    
    dotProduct = Ax * Bx + Ay * By;
    t = dotProduct / segmentLengthSq;
    t = max(0, min(1, t));
    
    Px = x1 + t * Bx;
    Py = y1 + t * By;
    
    distToClosestPointSq = (ox - Px)^2 + (oy - Py)^2;
    collision = (distToClosestPointSq <= radius^2);
end
function [pose, dataValid] = fetchRobotPose(mqttHandle, limoNum, ALL_CFG, prevPose, dt)
    pose = [0, 0, 0];
    dataValid = false;
    try
        mqttMessage = peek(mqttHandle);
        if isempty(mqttMessage)
            return;
        end
        expectedTopic = sprintf('rb/limo%s', limoNum);
        if ~strcmp(char(mqttMessage.Topic), expectedTopic)
            return;
        end
        jsonString = char(mqttMessage.Data);
        dataJson = jsondecode(jsonString);
        if ~isfield(dataJson, 'pos') || ~isfield(dataJson, 'rot')
            return;
        end
        
        mocapX = dataJson.pos(1);
        mocapY = dataJson.pos(3); 
        
        x = mocapX - ALL_CFG.mocapOriginX;
        y = -(mocapY - ALL_CFG.mocapOriginY);
        
        if ~isempty(prevPose) && dt > 0
            dx = x - prevPose(1);
            dy = y - prevPose(2);
            currentSpeed = sqrt(dx^2 + dy^2) / dt;
            speedThreshold = 0.05; 
            if currentSpeed > speedThreshold
                theta = atan2(dy, dx);
            else
                theta = prevPose(3);
            end
        else
            if length(dataJson.rot) >= 3
                theta = -dataJson.rot(3);
            else
                theta = 0;
            end
        end
        
        pose = [x, y, theta];
        dataValid = true;
    catch
    end
end
function [lookaheadX, lookaheadY, lookaheadIndex, crossTrackError] = ...
    findLookahead(robotX, robotY, plannedPath, lookaheadDistance)
    
    allDistances = sqrt((plannedPath.x - robotX).^2 + (plannedPath.y - robotY).^2);
    [crossTrackError, closestIndex] = min(allDistances);
    
    sClosest = plannedPath.s(closestIndex);
    sLookaheadTarget = sClosest + lookaheadDistance;
    
    if sLookaheadTarget > plannedPath.s(end)
        lookaheadIndex = length(plannedPath.x);
    else
        lookaheadIndex = find(plannedPath.s >= sLookaheadTarget, 1, 'first');
        if isempty(lookaheadIndex)
            lookaheadIndex = length(plannedPath.x);
        end
    end
    
    lookaheadX = plannedPath.x(lookaheadIndex);
    lookaheadY = plannedPath.y(lookaheadIndex);
end
%% GET KEN COMMAND BLOCK
function getCommand(mqttClient, robotID)
    % Subscribe to read STOP, WAIT, ETC commands
   commandsTopic = "cmd/limo" + robotID;
   subscribe(mqttClient, commandsTopic, Callback=@robotCommandsHandler);
end
function robotCommandsHandler(topic, data)
    global MainCommand; 
    % Note: data should be the command string ('GO', 'STOP', 'WAIT')
    MainCommand = char(data); 
end
%% GET KEN GOAL POINT
function getGoal(mqttClient, robotID)
    % 3. Subscribe to read STOP, WAIT, ETC commands and to read GOAL
   commandsTopic = "goal/limo" + robotID;
   subscribe(mqttClient, commandsTopic, Callback=@goalHandler);
end
function goalHandler(topic, data)
    global GOAL; 
    GOAL = jsondecode(data).goal; % Should be STOP, GO, WAIT, etc
end
